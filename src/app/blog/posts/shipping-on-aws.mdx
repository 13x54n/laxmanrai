---
title: "Shipping on AWS: Services and Patterns That Work"
summary: "Using AWS effectively for hosting, APIs, storage, and serverless—without drowning in services."
publishedAt: "2025-02-08"
tag: "AWS"
---

Amazon Web Services can feel like a labyrinth the first time you open the console. There are over 200 services, each with overlapping names and endless options. But here’s the good news: you don’t need to know them all to build and ship real apps.

In most cases, you can do 80% of everything with just **five to seven core services**. The trick is to pick the right foundational ones and learn them *well*.

This post covers the practical AWS setup I’ve used in production across multiple startups and side projects — the boring-but-reliable stack that actually ships.

---

## Compute: Lambda and containers

### AWS Lambda — the 80/20 choice

If your traffic is spiky or you’re running simple APIs, **AWS Lambda** is the default choice. It’s cheap, automatically scales, and you never patch servers.

A minimal Lambda API looks like this when paired with **API Gateway**:

```js
// index.mjs
export const handler = async (event) => {
  const name = event.queryStringParameters?.name ?? "world";
  return {
    statusCode: 200,
    body: JSON.stringify({ message: `Hello, ${name}!` }),
  };
};
```

Deploy via the AWS Console, **Serverless Framework**, or **AWS SAM** if you prefer templates:

```yaml
# template.yaml
Resources:
  HelloFunction:
    Type: AWS::Serverless::Function
    Properties:
      Runtime: nodejs20.x
      Handler: index.handler
      MemorySize: 128
      Timeout: 5
      Events:
        Api:
          Type: Api
          Properties:
            Path: /hello
            Method: get
```

**Pro tips:**
- Keep functions under 50 MB (zipped) including dependencies.
- Use **environment variables** for config, not hard-coded values.
- Turn on **provisioned concurrency** for performance-critical endpoints.
- Use **CloudWatch Logs Insights** to debug quickly.

### Containers when you need flexibility

**ECS Fargate** and **App Runner** give you long‑running compute without needing to manage EC2.

If your app has persistent connections, WebSockets, or background tasks, containers make more sense than Lambda.

Typical pattern:
- Dockerize your Node.js or Go app.
- Push to **Elastic Container Registry (ECR)**.
- Deploy to ECS with Fargate (for pure serverless containers) or App Runner (for web apps with automatic HTTPS).

Example `Dockerfile`:

```dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
CMD ["node", "server.js"]
```

App Runner automatically builds and deploys from GitHub — no infrastructure scripts needed.

---

## Storage and data

AWS gives you three main primitives for data storage. If you learn **S3**, **RDS**, and **DynamoDB**, you can cover 95% of backend use cases.

### 1. S3 — object storage

Think of **S3** as your infinite file cabinet for everything that isn’t a database record: uploads, images, backups, static websites.

**Checklist:**
- Enable **Block Public Access** by default.
- Use **lifecycle policies** to move older files to Glacier or delete stale data.
- Version buckets when storing critical files.

CLI example:

```bash
aws s3 mb s3://my-app-assets
aws s3 cp ./public/logo.png s3://my-app-assets/
```

You can even host a static site directly on S3:

```bash
aws s3 website s3://my-site-bucket/ --index-document index.html
```

Combine with **CloudFront** for global performance (more on that below).

---

### 2. RDS — managed relational databases

For transactional systems (users, payments, products), stick with **Postgres** or **MySQL** on **RDS**.

AWS handles the backups, patching, and scaling for you. You still get real SQL, ACID transactions, and schema constraints.

**Tips for production:**
- Enable **Multi-AZ** for failover.
- Schedule **automatic backups**.
- Use **parameter groups** to tune performance.
- Rotate credentials with **AWS Secrets Manager**.

Connection example (Node.js + Postgres):

```js
import pg from "pg";
const pool = new pg.Pool({
  host: process.env.DB_HOST,
  port: 5432,
  database: "appdb",
  user: process.env.DB_USER,
  password: process.env.DB_PASS,
  ssl: { rejectUnauthorized: true },
});
```

---

### 3. DynamoDB — serverless NoSQL

If you don’t need joins and want sub‑10 ms queries at any scale, use **DynamoDB**. It’s fully serverless and built for throughput.

The key to DynamoDB is **designing around your access patterns**, not your schema. That means thinking: *“How will I retrieve this data?”* instead of *“How will I store it?”*

Example item:

```json
{
  "PK": "USER#123",
  "SK": "PROFILE",
  "email": "user@example.com",
  "createdAt": "2026-02-20T17:00:00Z"
}
```

Query for all user-related data by `PK`, and create **Global Secondary Indexes (GSIs)** for alternate lookups (e.g., by email).

And yes, it can power entire production apps — DynamoDB backs many of Amazon’s services.

---

## Networking and CDN

AWS’s networking stack can get deep fast, but you really need just a few core concepts:

### CloudFront — your CDN layer

Put **CloudFront** in front of any origin (S3 bucket, API Gateway, or ECS app).  
It reduces latency by caching globally and offloads DDoS risk.

```bash
aws cloudfront create-distribution \
  --origin-domain-name my-app-assets.s3.amazonaws.com
```

Default TTLs can be overridden for dynamic content, and you can serve static assets (like images and JS bundles) from edge caches close to your users.

### API Gateway — routing for serverless APIs

Pair **API Gateway** with Lambda to handle REST or WebSocket APIs without standing up a Node server.

Benefits you get for free:
- Input validation
- Auth via IAM or Cognito
- Rate limiting and caching
- Automatic health monitoring

Downside: pricing can spike for very high‑volume apps. For that, switch to **ALB (Application Load Balancer)** with Lambda or ECS.

### VPCs and security groups

Everything inside AWS lives on virtual private networks. Default VPCs work fine for small apps, but production systems should explicitly define:
- Private subnets for your databases
- Public subnets for load balancers or gateways
- Security groups for port‑level control  

Rule of thumb: **never expose RDS directly to the internet**. Always use VPC rules or an internal bastion to access it.

---

## Cost and operations

AWS can surprise you — both in power and in pricing. Wrangle it early.

### 1. Tag everything
Every resource should have tags like:
```text
Environment=production
Team=backend
Service=api
```
Tags make cost allocation and cleanup actually possible.

### 2. Set budgets and alarms
Use **AWS Budgets** or **Cost Anomaly Detection** to catch runaway costs before the bill arrives. Even small prototypes have been known to rack up hundreds overnight due to a misconfigured API Gateway loop.

### 3. Start small, scale later
A minimal AWS stack that handles thousands of users reliably:
- **Lambda + API Gateway** → APIs  
- **DynamoDB or RDS** → storage  
- **S3 + CloudFront** → static assets or web hosting

You can add caching (ElastiCache), queues (SQS), or monitoring (CloudWatch Metrics, X-Ray) *when* you feel the pain — not before.

### 4. Prefer managed over manual
It’s tempting to “run EC2 because it’s cheaper.” But add patching, monitoring, TLS, scaling, and you’ve reinvented what AWS services already do better.

Let AWS handle the undifferentiated heavy lifting. Your time is more valuable.

---

## Wrapping up

The real skill with AWS isn’t memorizing services — it’s knowing which ones **not** to use.  
Stick to these foundations:

- **Lambda or ECS** for compute  
- **S3, RDS, DynamoDB** for data  
- **CloudFront + API Gateway** for delivery and routing  
- Basic networking, tagging, and cost control for sanity  

Master those, and you’ll be able to ship confidently — without needing a 15‑service architecture or a team of cloud specialists.

Less is more on AWS. Master the core, ship faster, and sleep better.